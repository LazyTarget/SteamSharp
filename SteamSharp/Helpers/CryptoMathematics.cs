using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SteamSharp.Helpers {
	
	internal static class CryptoMathematics {

		/// <summary>
		/// Bitwise XOR for 2 byte arrays.  Arrays must be the same length.
		/// </summary>
		/// <param name="t1">Left side for comparison</param>
		/// <param name="t2">Right side for comparison</param>
		/// <returns>Resulting byte array</returns>
		static internal byte[] BitwiseXOR( byte[] t1, byte[] t2 ) {
			//Inputs need to be the same length	for this implementation
			if( !( t1.Length == t2.Length ) ) {
				throw new ArgumentException( "Input arrays must have the same length" );
			}

			byte[] result = new byte[t1.Length];
			byte bytXOR = 0;

			for( int i = 0; i <= t1.Length - 1; i++ ) {
				bytXOR = BitwiseXOR( t1[i], t2[i] );

				result[i] = bytXOR;
			}

			return result;
		}

		/// <summary>
		/// Bitwise XOR for 2 Bytes.
		/// </summary>
		/// <param name="t1">Left side for comparison</param>
		/// <param name="t2">Right side for comparison</param>
		/// <returns>Resulting byte</returns>
		static internal byte BitwiseXOR( byte t1, byte t2 ) {

			BitArray baLft = null;
			BitArray baRght = null;
			BitArray baXor = null;

			//Have to use Byte Arrays as the constructor for the BitArray, otherwise the 
			//integer value of the current byte is used to set the length of the bitArray instead of the value.
			byte[] bytL = new byte[1];
			byte[] bytR = new byte[1];

			bytL[0] = t1;
			bytR[0] = t2;
			baLft = new BitArray( bytL );
			baRght = new BitArray( bytR );
			baXor = baLft.Xor( baRght );

			byte[] ba2BytArr = new byte[8];

			IEnumerator enumbaXor = baXor.GetEnumerator();
			ba2BytArr = baXor.ToByteArray();

			return ba2BytArr[0];

		}

		/// <summary>
		/// Convert the input Integer to an Octet String.
		/// </summary>
		/// <param name="x">input integer</param>
		/// <param name="size">size in octets (bytes)</param>
		/// <returns>Resulting byte array of specified length</returns>
		static internal byte[] I2OSP( int x, int size ) {
			byte[] bytVal = BitConverter.GetBytes( x );

			byte[] result = new byte[size];
			Buffer.BlockCopy( bytVal, 0, result, ( result.Length - bytVal.Length ), bytVal.Length );

			Array.Reverse( result );

			return result;
		}

		/// <summary>
		/// Mask generation function.
		/// </summary>
		/// <param name="seed">Seed</param>
		/// <param name="maskLen">Length of generated mask</param>
		/// <param name="hashLength">Length of the hash produced by the supplied hash provider</param>
		/// <param name="hashProvider">Hash provider to use in mask generation</param>
		/// <returns>Generated mask of specified length</returns>
		static internal byte[] OAEPMGF( byte[] seed, int maskLen, int hashLength, HashProviders.IHashProvider hashProvider ) {
			byte[] result = new byte[maskLen];

			//Determine how many interations we have to do.  We'll be appending 
			//m_hLen (hash length) bytes for every iteration, so the size of the generated byte array 
			//will be m_hLen * iNum (number of iterations).
			int iNum = (int)Math.Floor( (double)( maskLen / hashLength ) ) + 1;

			//Mask that will be truncated to create the final 
			//resulting mask returned by this function.
			byte[] bytLongMask = new byte[( iNum * hashLength )];

			byte[] bytAppend = new byte[4];
			byte[] bytTmp = null;
			int iPadLen = 0;
			byte[] bytSeedHash = new byte[hashLength];

			//Padded pseudorandom seed to be hashed.
			byte[] bytPadSeed = new byte[( seed.Length + 4 )];
			seed.CopyTo( bytPadSeed, 0 );

			for( int i = 0; i <= iNum - 1; i++ ) {
				//Convert the iterator to an Octet String byte array
				bytTmp = CryptoMathematics.I2OSP( i, 4 );

				//Calculate the needed padding zeros, and add 
				//them to the resulting Array.  Result must be 4 bytes long.
				iPadLen = bytAppend.Length - bytTmp.Length;

				bytTmp.CopyTo( bytAppend, 0 );

				//Hash the pseudorandom padded seed and append it to the 
				//long version of the mask.
				bytAppend.CopyTo( bytPadSeed, seed.Length );
				bytSeedHash = hashProvider.ComputeHash( bytPadSeed );
				bytSeedHash.CopyTo( bytLongMask, i * hashLength );
			}

			//Copy the first maskLen bytes of bytLongMask to the result
			//and return the result.
			Array.Copy( bytLongMask, result, maskLen );

			return result;

		}

	}

}
